(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{65:function(n){n.exports={data:{allBlogPost:{pageInfo:{totalPages:1,currentPage:1},edges:[{node:{id:"8a2077d36b61d835d91e274760996b61",date:"14 February, 2019",title:"Execution context and Execution Stack in javascript",path:"/BlogPost/exec-context-stack",content:'<p>ไหนๆวันนี้ก็เป็นวันวาเลนไทน์ของใครหลายๆคนแล้วแต่สำหรับผมมันก็แค่วันพฤหัสบดีที่แสนธรรมดา... เอาเวลาที่อิจฉาคนมีคู่มาเขียนบทความดีกว่า =__+\'\nสวัสดีครับกลับมาผมกับผมต้าคนเดิมคนดี วันนี้ผมรู้สึกคึ้กไปอ่านเรื่อง execution context กับ execution stack มาครับก็เลยมาเล่าให้ฟังครับ เริ่ม~~~ </p>\n<p>ขอเกริ่นก่อนว่ามันคือ Stack ใน data structure นั้นเองครับทีนี้มาเข้าเรื่องกันเลยดีกว่า</p>\n<h4 id="execution-context"><a href="#execution-context" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Context</h4>\n<p>มันคือสภาพแวดล้อมสำหรับ Javascript ครับ สำหรับ running process ทั้งหมดโดยตัว execution context จะถูกแบ่งออกเป็น 3 ตัวครับ ตามนี้เลย</p>\n<br>\n<p><strong>Global</strong> => เหมือนกับก้อน object ใหญ่ๆที่เก็บ function สำคัญๆเอาไว้ ถ้านึกไม่ออกก็คือมันคือ <em>window</em> หรือ <em>this</em> ใน javascript นั้นแหล่ะครับ</p>\n<br>\n<p><strong>Functional</strong> => มันจะถูกสร้างเมื่อมีการเรียกใช้ function ครับ</p>\n<br>\n<p><strong>Eval</strong> => ตัวนี้จะถูกสร้างก็ต้องเมื่อเรียกใช้ <em>eval()</em> </p>\n<br>\n<p>ตอนนี้ทุกคนก็พอรู้จัก execution context ในรูปแบบต่างๆแล้วนะครับ มาต่อกันที่ execution stack กันเลย 1 2 ฮึ้บ...</p>\n<br>\n<h4 id="execution-stack"><a href="#execution-stack" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Stack</h4>\n<p>ก่อนอื่นผมขออธิบายคร่าวๆเรื่อง stack ก่อนนะครับซึ่ง stack มันมี operation 2 อันคือ push กับ pop ซึ่งเป็นโครงสร้างการเก็บข้อมูลแบบนึงที่เป็นการทำงานแบบ LIFO(last in first) คือการเข้าทีหลังออกก่อนนั้นเอง ถ้าทุกคนยังไม่เข้าใจอยู่ ปริ้งภาพมา~~~</p>\n<p><img src="https://i.imgur.com/S38kijr.png" alt="S38kijr.png"></p>\n<p>แค่รูปนี้ทุกคนคงเข้าใจกันแล้ว ง่ายๆเลยคือ push คือการเพิ่มข้อมูลไว้บนสุดส่วนเจ้า pop คือการเอาข้อมูลที่อยู่บนสุดออกไปครับ ตัว Execution stack คือการที่เราเอาการเรียก function ไปเก็บลง stack นั้นเองครับเพื่อรอให้เจ้านายเรียกไปใช้งานนั้นเอง มันเป็นทำนองคลองเดียวกันเลยครับ ลองมาดูโค๊ดตัวอย่างพร้อมรูปภาพการทำงานกันเลยครับ</p>\n<pre><code>let a = 5;\nlet b = 10\nfunction add(x,y){\n  return x + y;\n}\n\nconst c = add(a,b);\n</code></pre>\n<p><img src="https://i.imgur.com/G02Mdah.png" alt="Imgur">\nทุกคนจะเห็นว่าตัว <em>add()</em> จะถูกเก็บลง call stack ก่อนเพื่อรอเจ้านาย(Global execution) เรียกใช้งานหลังจากนั้น <em>add()</em> ก็ถูกเรียกใช้ครับ เอ๊ะ! ผมลืมบอกว่า function, variable จะถูกเก็บลง global memory ไว้ก่อนนะครับ มาต่อที่ภาพที่สองกันเลย</p>\n<p><img src="https://i.imgur.com/5V0G5e4.png" alt="Imgur">\nหลังจากที่ตัว global execution ได้ทำการใช้งานทาส <em>add()</em> เป็นที่สำเร็จเสร็จสิ้นแล้ว พี่ global ส่งผลลัพธ์ไปเก็บที่ตัวแปร <em>C</em> ใน global memory เพื่อใช้งานต่อไป</p>\n<p>ก็จบไปแล้วสำหรับบทความนี้ถ้าใครค้างคาใจกับมาเรื่องก็มาคุยกับพวกเราได้ที่ Fanpage ได้นะครับ สำหรับวันนี้ก็ของลาไปก่อน สวัสดีวันวาเลนไทน์ครับ</p>\n<p>Ref:</p>\n<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="nofollow noopener noreferrer">Execution context and stack</a></p>\n<p><a href="https://www.valentinog.com/blog/js-execution-context-call-stack/" target="_blank" rel="nofollow noopener noreferrer">What Is The Execution Context?</a></p>\n',description:"ใครที่เขียน Javascript แล้วไม่รู้จัก 2 ตัวนี้ต้องอ่านเลยครับ ผมพยายามอธิบายให้เข้าใจง่ายที่สุดดดดดด",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/iX19pbS.png"}}},{node:{id:"7637040550a982b3e528645bfdfbd7e9",date:"13 February, 2019",title:"Hoisting ใน Javascript คืออะไร",path:"/BlogPost/Hoisting-Javascript",content:'<p>สำหรับใครที่เคยชินกับ var มาแล้วคงเข้าใจอยู่แล้วว่ามี let &#x26; const ที่มาแทนที่รุ่นพี่ไปแล้วเพราะว่า 2 ตัวนี้แก้ปัญหาหาเรื่อง hoisting แต่ๆ ส่วนใหญ่แล้วเราเคยได้ยินอย่างว่า\n<br>\n<br></p>\n<p class="qoute">\n  อย่าไปใช้ var นะเพราะมันให้เกิด hoisting\n</p>\n<p>แล้วอะไรคือ hoisting กันล่ะวันนี้ผมจะมาอธิบายให้ฟังกันครับ เริ่ม~~~</p>\n<br>\n<h5 id="hoisting-"><a href="#hoisting-" aria-hidden="true"><span class="icon icon-link"></span></a>Hoisting ?</h5>\n<p>       hoisting คือการประกาศตัวแปรแต่ยังไม่มีการกำหนดค่าเข้าไป และอุ้มตัวแปรไปอยู่บนสุดครับ</p>\n<br>\n<pre><code>console.log(a);\n    var a = \'สวัสดีครับ\';\n</code></pre>\n<br>\nถ้าเป็นภาษาอื่นมันคง error ว่าไม่ได้มีการประกาศตัวแปร a โว้ยไปประกาศส่ะ แต่!ใน JS อะไรก็เกิดขึ้นได้ถ้ามีปาปิก้า มันจะขึ้นว่า\n undefined แทน... เอ้าเป็นไปได้ไงมันต้อง error สิฟ๊ะ ตอนนี้ทุกคนกำลัง งงว่ามันเกิดขึ้น มันมีชื่อเรียกว่า lexical environment ครับ...\n<br>\n<br>\n<h4 id="lexical-environment-"><a href="#lexical-environment-" aria-hidden="true"><span class="icon icon-link"></span></a>Lexical environment ?</h4>\n<p>      ผมเดาว่าเป็นคำที่ทุกคนไม่คุ้นหูแน่ๆเลย แต่เอาเป็นว่าช่างมันเถอะครับ ก่อนอื่นผมของเรียกมันว่าเจ้า lex ก็แล้วกันนะครับจะได้คุ้นหูกัน ผมจะอธิบายว่าเจ้านี้คืออะไร เอาไว้ทำอะไร สำคัญยังไง</p>\n<br>\n<p>       1. คือ ? ==> มันคือกล่องใบนึงครับที่เอาไว้เก็บ variable, function ที่จะเอาไปใช้งานใน software ของเราครับ</p>\n<pre><code>LexicalEnvironment = {\n      Identifier:  &#x3C;value>,\n      Identifier:  &#x3C;function object>\n    }\n</code></pre>\n<br>\n<p>รูปแบบมันก็จะประมาณนี้ครับ เมื่อใดก็ตามที่เราประกาศตัวแปร <strong><em>var a = \'name\'</em></strong> อย่างนี้ตัวเจ้า lex จะเป็นอย่างนี้</p>\n<pre><code>LexicalEnvironment = {\n      a:  \'name\',\n    }\n</code></pre>\n<p>จะเห็นว่ามีการกำหนดค่าให้ a ลงไปประมาณนี้ครับ</p>\n<br>\n<p>       2. ปัญหา ? ==> แล้วเจ้า lex มันจะมีปัญหาคืออะไรก็ปรกติดีนี้น๊า ในความปรกติมีความไม่ปรกคือ ถ้าสมมุติว่าทำแบบนี้ล่ะ</p>\n<pre><code>   var a;\n      console.log(a);\n      a = "Tar";\n</code></pre>\n<br>\n<p>จะเห็นว่าประกาศตัวแปรแต่ไม่ได้กำหนดค่าไปแล้วแสดงข้อความออกไปเลย มันต้อง error แน่ๆเลย แต่!! ต้องกันข้ามเลยมันจะไม่ error แต่จะเป็น  undefined  ดังนั้นตัวเจ้า lex จะเป็นแบบนี้คือการที่เจ้า lex เนี๊ยจะทำการกำหนดค่าให้ตัวแปรที่ประกาศไปแล้วแต่ยังไม่กำหนดค่าให้เป็น undefined ไว้ก่อน</p>\n<pre><code>LexicalEnvironment = {\n      a: undefined,\n    }\n</code></pre>\n<br>\n<p>แล้วมันถึงไปกำหนดค่าไปหลังจาก console.log(a)</p>\n<pre><code>LexicalEnvironment = {\n      a: \'Tar\',\n    }\n</code></pre>\n<p>นี้ก็คือการทำงานที่เรียกกันว่า <strong>Hoisting</strong> ครับ</p>\n<br>\n<h4 id="ใช้-let--const-กันกว่า"><a href="#%E0%B9%83%E0%B8%8A%E0%B9%89-let--const-%E0%B8%81%E0%B8%B1%E0%B8%99%E0%B8%81%E0%B8%A7%E0%B9%88%E0%B8%B2" aria-hidden="true"><span class="icon icon-link"></span></a>ใช้ let &#x26; const กันกว่า</h4>\n<br>\n<p class="qoute">\n  ก็ไปใช้ let & const แทนการใช้ var กันเถ๊อะ!!!!\n</p>\n<br>\n<p>      คงนี้ไม่พ้นกับการใช้ let &#x26; const แต่หารู้ไม่ว่าเจ้าสองตัวนี้ก็ไม่ต่างจาก var มากมันไม่ได้หนีไปจากเจ้า lex เลยแต่แค่เปลี่ยนค่ามันแค่นั้นเองแทนที่จะเป็น undefined ก็เป็น uninitialized แทน งั้นผมยกตัวอย่างดีกว่า</p>\n<pre><code>let a;\n    console.log(a);\n    a = "Tar";\n</code></pre>\n<br>\n<p>ตรงตัวแปร a เจ้า lex จะเป็นแบบนี้แทน</p>\n<pre><code>LexicalEnvironment = {\n      a: &#x3C;uninitialized>\n    }\n</code></pre>\n<p>ทุกคนเห็นไว้ว่ามัน make sense กว่าแทนที่จะ undefined ส๊ะอีกนะครับ เย้!! ในที่สุดผมก็เขียนเสร็จสักทีครับ สำหรับใครอยากเห็นตัวอย่างมากขึ้นไปอ่านที่ devhoy ได้เลยครับผมทิ้งไว้ข้างล่างให้นะครับ สวัสดีครับ</p>\n<br>\n<p>ปล. ที่จริงมันมีเรื่อง Execution Context และ Execution Stack อีกถ้าผมไม่ลืมผมจะมาอธิบายนะครับ ขอไปให้อ่านให้เข้าใจก่อนนะครับ</p>\n<br>\n<p>Ref:</p>\n<p><a href="https://blog.bitsrc.io/hoisting-in-modern-javascript-let-const-and-var-b290405adfda" target="_blank" rel="nofollow noopener noreferrer">Hoisting in Modern JavaScript</a></p>\n<p><a href="devahoy.com/posts/javascript-variable-hoisting/">DevAhoy - hoisting</a></p>\n',description:"ท่านใดที่เขียน Javascript จะรู้ดีว่าถ้าใครใช้ var มันจะเกิด Hoisting เสมอ ผมเลยจะมาอธิบายว่า hoisting คืออะไร ทำงานยังไงกัน",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/GYwt6rf.png"}}},{node:{id:"349f3a413b76b874add1ab0b0351b384",date:"10 February, 2019",title:"NodeJS Event Emitter สำคัญฉะไหน",path:"/BlogPost/NodeJS-EventEmitter",content:'<p>วันนี้เราจะได้รู้กันว่าตัว NodeJS คืออะไร ดียังไง เริ่มได้~~~</p>\n<p><br/><br/></p>\n<h4 id="node-event-emitter-"><a href="#node-event-emitter-" aria-hidden="true"><span class="icon icon-link"></span></a>Node Event Emitter ?</h4>\n<p>      ด้วยความที่ว่า NodeJS เองทำงานเป็นแบบ event-driven architecture หรือเรียกแบบไทยๆว่าการขับเคลื่อนทุกอย่างด้วย Event มาถึงตรงนี้ทุกคนคงจะงงว่าแล้วตัว event-driven คืออะไร</p>\n  <p align="center">\n    <img src="https://i.imgur.com/yZjiHQy.jpg">\n  </p>  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;รูปนี้ทุกคนคงเข้าใจ event driven ทุกคนจะเห็นว่ามันคือ Observer design pattern นั้นเองนะครับซึ่งตัว Observer pattern เองเป็นฐานในการทำ event driven ผมขอไม่ลงลึกเรื่อง Observer pattern ง่ายๆก็คือ Observer pattern เอาไว้สำหรับสังเกตุการเปลี่ยนแปลงข้อมูลว่าเปลี่ยนแปลงไปยังไงบ้างนั้นเองครับ\n<br/><br/>\n<h4 id="node-event-ใช้งานยังไง-"><a href="#node-event-%E0%B9%83%E0%B8%8A%E0%B9%89%E0%B8%87%E0%B8%B2%E0%B8%99%E0%B8%A2%E0%B8%B1%E0%B8%87%E0%B9%84%E0%B8%87-" aria-hidden="true"><span class="icon icon-link"></span></a>Node Event ใช้งานยังไง ?</h4>\n<p>มาเริ่มใช้ Event emitter กันเลยครับผมขอวาดภาพว่าเราจะทำ service อะไรด้วย Event Emitter นะครับ</p>\n<p><img src="https://i.imgur.com/OECu3Yh.png" alt="OECu3Yh.png"></p>\n<p>ผมจะลองเขียนตามนี้นะครับ เริ่ม~~~\n<br/><br/>\n<strong>#1 ทำการสร้าง require และสร้าง event ตัวนึง</strong></p>\n<pre><code>const EventEmitter = require(\'events\');\n    const myService = new EventEmitter();\n</code></pre>\n<p><br/><br/>\n<strong>#2 สร้างตัว emit data</strong></p>\n<pre><code>// ให้มีการส่งข้อมูลทุกๆ 1 วินาที\n  setInterval(()=>{\n    myService.emit(\'registration\',{\n          name: "Tar",\n          email: "Tar@email.com"\n       })\n  },1000)\n</code></pre>\n<p>ต้องอธิบายก่อนว่าตัว registration คือชื่อ event ครับส่วนตัว object คือข้อมูลที่เราจะส่งผ่านตัว regitration event</p>\n<p><br/><br/>\n<strong>#3 สร้างตัว listener สำหรับ email &#x26; admin</strong></p>\n<pre><code>  // ใครยังไม่เคยใช้ => หรือ arrow function ผมมี ref ไว้ข้างล่างครับ\n  // email service\n  myService.on(\'registration\', (userData) => {\n    console.log("\\n\\n");\n    console.log(`ส่ง email ไปหาคุณ ${userData.name} ไปที่ ${userData.email}`)\n  })\n\n  // admin service\n  myService.on(\'registration\', (userData)=>{\n    console.log(`เจ้านายครับมีลูกค้าสมัครสมาชิก คุณ ${userData.name}$`)\n  })\n</code></pre>\n<p><br/><br/>\n<strong>#4 โค๊ดเต็มๆตามนี้เลยครับ</strong></p>\n<pre><code>  const EventEmitter = require(\'events\');\n      const myService = new EventEmitter();\n\n      setInterval(()=>{\n        myService.emit(\'registration\',{\n              name: "Tar",\n              email: "Tar@email.com"\n           })\n        },1000)\n\n      myService.on(\'registration\', (userData) => {\n        console.log("\\n\\n");\n        console.log(`ส่ง email ไปหาคุณ ${userData.name} ไปที่ ${userData.email}`)\n      })\n\n\n      myService.on(\'registration\', (userData)=>{\n        console.log(`เจ้านายครับมีลูกค้าสมัครสมาชิก คุณ ${userData.name}$`)\n      })\n</code></pre>\n<br/>\n<p><strong>#5 มาดูผลลัพธ์กันเลยครับ</strong></p>\n<p align="center">\n  <img src="https://i.imgur.com/i7sXG6v.png" width="50%">\n</p>  \n<br/>\n<br/>\nก็จบกันไปแล้วนะครับสำหรับ NodeJS Event Emitter แบบพื้นฐานมาก!!!! ผมก็หวังว่าผู้อ่านจะเข้าใจการทำงานและการเขียน Event Emitter นะครับผม วันนี้ผมต้าขอตัวลาไปก่อนชะแว๊บ~~~\n<br/>ปล. เดี๋ยวจะมาเขียนเพิ่มเติมว่าไปปรับใช้งานยังไงนะครับ ^ _ ^\n<br/><br/>\n<p>Ref:</p>\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="nofollow noopener noreferrer">Arrow functions</a></p>\n<p><a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="nofollow noopener noreferrer">Event-driven architecture</a></p>\n<p><a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="nofollow noopener noreferrer">Observer pattern</a></p>\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="nofollow noopener noreferrer">Template literals</a></p>\n',description:"ผมเห็นหลายๆคนที่เขียน NodeJS แล้วไม่ค่อยมีคนใช้ EventEmitter หรือบางทีก็ใช้",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/7oG5ce7.png"}}},{node:{id:"67c5dae4bf3034994e3e0d6fb27f7a90",date:"10 February, 2019",title:"Pipe function ใน Javascript",path:"/BlogPost/Pipe-Javascript",content:'<p>สำหรับใครที่เคยใช้เจ้าแพะหรือ ramdaJS มาก่อนคงได้ยินหรือเคยใช้ pipe() มาอยู่แล้ว ซึ่งพี่ pipe() เอาไว้ทำอะไรน่ะเหรอ ดูตัวอย่างเลยครับ</p>\n<pre><code>getFirstChar( toLowerCase(data))\n</code></pre>\n<p>ทุกเห็นคงคิดว่าก็ไม่เห็นมีไรเลยซับซ้อนตรงไหนแค่ 2 functions เอง แต่ถ้าสมมุติเป็นแบบนี้ล่ะ</p>\n<pre><code>getFirstChar( toLowerCase(convertAsciiToText(getName(data))))\n</code></pre>\n<p><img src="https://firebasestorage.googleapis.com/v0/b/myblog-7f48d.appspot.com/o/flamelink%2Fmedia%2F1545679658057_1545660065385_holy-shit-what-dc0kau.jpg?alt=media&#x26;token=494d24a5-5bba-42fc-a2c0-6fa7b851a73f"></p>\n<p>เฮ๊<del></del>~~ ทุกคนกำลังคิดแบบนี้อยู่แน่ๆ</p>\n<p>ก่อนที่เราจะมาพูดถึงวิธีการแก้ไขปัญหา เรามาพูดถึงแนวคิดของเจ้า pipe กันก่อน ต้องย้อนกลับไปความรู้ทางคณิตศาสตร์ตอน ม. 5 การเลยคือเรื่อง relation and function ต้องขอบอกก่อนว่าผมก็ไม่เก่งคณิตศาสตร์แต่ผมจะพยายามอธิบายให้ง่ายที่สุดเท่าที่จะทำได้นะครับ</p>\n<p><strong>Math #1 basic function</strong></p>\n<br/>\nสมมุติว่าผมสร้าง function ตัวนึงสำหรับรับค่า x เพื่อนำไปบวก 2\n<pre><code>f(x) = x + 2\n</code></pre>\n<br/>\nทีนี้ผมสร้างอีก function นึงสำหรับรับค่า x แล้วทำไปคูณ 5\n<pre><code>g(x) = x * 5\n</code></pre>\n<br/>\nเริ่มจาก function แรกก่อน\n<pre><code>f(2) = 2 + 2\n     = 4\n</code></pre>\n<br/>\nต่อมาตัวก็เป็น function g\n<pre><code>g(2) = 2 * 5\n     = 10\n</code></pre>\n<br/>\nนี้ก็เป็นตัวอย่างเล็กๆน้อยจากเรื่อง function สำหรับ ม. 5 ต่อไปมาเริ่มในสิ่งที่ยากขึ้นอีกระดับนึงเรียกว่า composite function เริ่ม!!\n<p><strong>Math #2 Composite function</strong>\n<br/>\nง่ายๆมันคือการรวม function เข้าด้วยกันนั้นเอง ผมขอยก 2 functions ด้านบนมาด้วยนะครับจะได้ไม่เสียเวลา มันก็จะได้แบบนี้</p>\n<br/>\nอันดับแรกผมเอา 2 function2 นี้รวมกัน\n<pre><code>f(g(x))\n</code></pre>\n<br/>\nผมจะเขียนแนวการคิดไปทีละขั้นตอนเน้อ...\n<pre><code>f(g(x)) = f(x * 5)\n        = (x * 5) + 2\n</code></pre>\n<br/>\nลองมาดูตัวอย่างกัน\n<pre><code>f(g(2)) = f(2 * 5)\n        = (2 * 5) + 2\n        = 10 + 2\n        = 12\n</code></pre>\n<br/>\nเอ๊ะแล้วเจ้า pipe() สุดที่รักของเรามันเกี่ยวอะไรกับคณิตศาสตร์ชวนปวดหัว ผมต้องบอกเลยว่ามันคืออันเดียวกัน ผมจะเปรียบเทียบให้ดู\n<pre><code>f(g(x)) = getFirstChar( toLowerCase(data))\n</code></pre>\n<br/>\nเห็นมั๊ยว่าเหมือนกันเป๊ะๆ เรามาดูโค๊ด pipe() กันเลย\n<pre><code>const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x)\n</code></pre>\n<br/>\n<p>สำหรับใครที่ไม่รู้จัก Rest Parameter &#x26; Reduce Parameter ตามนี้โล๊ดวิธีการใช้ตัว pipe() ก็ตามนี้เลย</p>\n<br/>\n<pre><code>pipe(getFirstChar, toLowerCase, convertAsciiToText, getName)(data)\n</code></pre>\n<br/>\n<p>เห็นมั๊ยว่าสะดวกและอ่านงานกว่าเยอะ ถือว่าเป็นวิธีที่ดีมากๆเป็นไงบ้างครับ สำหรับอะไรแบบนี้</p>\n<br/>\nRef:\n<p><a href="https://medium.com/front-end-weekly/pipe-and-compose-in-javascript-5b04004ac937" target="_blank" rel="nofollow noopener noreferrer">pipe</a></p>\n<p><a href="https://medium.freecodecamp.org/how-do-javascript-rest-parameters-actually-work-227726e16cc8" target="_blank" rel="nofollow noopener noreferrer">rest parameter</a></p>\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="nofollow noopener noreferrer">reduce</a></p>\n',description:"ท่านใดเคยประสบปัญหาเรื่องการใช้ transformation function เยอะๆรึเปล่า ผมมีทางแก้มาทำเสนอ",author:"Tar Jarupong",image:{type:"image",mimeType:"image/jpeg",src:"https://i.imgur.com/fp0HTAi.jpg"}}},{node:{id:"cfbd7cdf15ecf548001e54bd9f0ca595",date:"9 February, 2019",title:"ทำไมเราถึงควรใช้ MongoDB native แทน Mongoose",path:"/BlogPost/NodeJS-%2B-MongoDB-native",content:'<p>โดยปรกติแล้วเราจะเห็นบทความส่วนใหญ่ จะเป็น NodeJS + Mongoose ซึ่งถ้าถามว่าดีมั๊ย?​ มันก็ดีแต่สิงที่จะประสบพบเจอก็คือเรื่อง performance</p>\n<table>\n<thead>\n<tr>\n<th>FindOne</th>\n<th>Find</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src="https://i.imgur.com/ZUiNwsA.png" alt="ZUiNwsA.png"></td>\n<td><img src="https://i.imgur.com/2487u8h.png" alt="2487u8h.png"></td>\n</tr>\n</tbody>\n</table>\n<br>\n<table>\n<thead>\n<tr>\n<th>Insert</th>\n<th>InsertMany</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><img src="https://i.imgur.com/gohqOjl.png" alt="gohqOjl.png"></td>\n<td><img src="https://i.imgur.com/abX1IC7.png" alt="abX1IC7.png"></td>\n</tr>\n</tbody>\n</table>\n<p>เราจะเห็นว่าตัว Op/sec ของตัว Mongoose ทำงานช้ากว่า MongoDB native เร็วกว่า 2 เท่า</p>\n<h3 id="แต่"><a href="#%E0%B9%81%E0%B8%95%E0%B9%88" aria-hidden="true"><span class="icon icon-link"></span></a>แต่!!</h3>\n<p>ทำไมเราถึงยังใช้ Mongoose อยู่ นั้นก็เพราะว่า Mongoose มันออกแบบมาแก้ปัญหาเรื่อง Callback ใน MongoDB native ยังไงล๊าเราลองมาดูโค๊ดกัน</p>\n<br>\n<p><strong>Mongoose</strong></p>\n<pre><code> const mongoose = require(\'mongoose\');\n\n    const mongoDB = \'mongodb://127.0.0.1/my_database\';\n    mongoose.connect(mongoDB);\n\n    mongoose.Promise = global.Promise;\n    const db = mongoose.connection;\n</code></pre>\n<br>\n<p><strong>MongoDB Native</strong></p>\n<pre><code> const MongoClient = require(\'mongodb\').MongoClient;\n    const url = "mongodb://localhost:27017/mydb";\n\n    MongoClient.connect(url, function(err, db) {\n      if (err) throw err;\n      db.close();\n    });\n</code></pre>\n<p>ทุกคนก็จะเห็นว่า ตัว MongoDB native มันเป็น callback ซึ่งมันจะเกิด callback hell ในที่สุดถ้าเรามีการทำ operation กับ MongoDB มาขึ้น\nแล้วเราจะแก้ไขยังไงดี นั้นสิทำยังไงดีล่ะครับท่านผู้ชม พอดีผมขี้เกียจเขียนต่อแล้วค่อยมาต่อคราวหน้านะขอรับ</p>\n<p>Ref:</p>\n<p><a href="https://medium.com/@bugwheels94/performance-difference-in-mongoose-vs-mongodb-60be831c69ad" target="_blank" rel="nofollow noopener noreferrer">performance-difference-in-mongoose-vs-mongodb</a></p>\n',description:"MongoDB Native มันดียังไงนะทำไมถึงน่าใช้",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/6YfCOxy.png"}}},{node:{id:"30334f237e476b6ea169e2463ee66dbe",date:"8 February, 2019",title:"สวัสดีชาวโลกกก V2",path:"/BlogPost/hello-world",content:"<p>คือเรื่องของเรื่องก็คืออยู่ๆรู้สึกว่าอีตัว firebase &#x26; flamelink มันเริ่มไม่ตอบโจทย์ด้วยเรื่องตัว editor ของเพราะด้วยความที่ว่ามันมี error เยอะมากและทาง flamelink ก็ไม่แก้ไขให้ผมสักที ก็ได้แค่รอร๊อรอ จนในที่สุดก็ตัดใจว่า ไปเขียน markdown ก็ได้ฟ๊ะแต่ด้วยความที่ตัวเองไม่ถนัด markdown อย่าเรียกว่าไม่ถนัดสิต้องเรียกเข้าั้นโง่ markdown มากๆเพราะไม่เคยใช้เลยจะไปเขียนใน atom editor ก็ช้าแล้วจะใช้อะไรดีล่ะ นั้นก็คือ boostnote.io นั้นเองมันมาช่วยให้ผมมีความรู้สึกอยากเขียน note มากขึ้น~ ที่จริงไม่เกี่ยวหรอกแค่อยากจะแยก markdown note ออกมาแค่นั้นฮ่าๆๆๆ ถ้าไปเขียน markdown ใน atom editor มันรู้สึกเหมือนตัวเองเขียนโค๊ดก็เลยคิดว่าถ้ามีเวลามาเขียน blog คงมาเขียนใน boostnote แทน ผมหมดเรื่องจะบ่นแล้วง๊าาาา~ ของจบเลยก็แล้วกันนะครับ ชะแว๊บบบบบบ</p>\n",description:"ผมกลับมาเขียน blog ดูอีกครั้งและ design เว็บใหม่",author:"Tar Jarupong",image:{type:"image",mimeType:"image/jpeg",src:"https://i.imgur.com/4X28DdS.jpg"}}}]}}}}}]);