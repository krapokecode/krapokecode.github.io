(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{66:function(e){e.exports={data:{allNodePost:{pageInfo:{totalPages:1,currentPage:1},edges:[{node:{id:"8680b76919f1d76b5ee0f0a53c23c4f0",date:"10 March, 2019",title:"NodeJS Stream ไหลดั่งสายน้ำ ตอนที่ 1 (Readable)",path:"/NodePost/node-stream-1",content:'<p>NodeJS stream นี้มันอะไรกันนะ มันสำคัญขนาดนั้นเลยเหรอ ไม่เห็นเคยได้ยิน ใช่ผมก็ไม่เคยได้ยินแต่ด้วยต่อมอยากเ-อก เอ้ยอยากรู้มันทำงานก็เลยได้ไปศึกษามาแล้วอยากจะเขียนบทความให้ทุกคนได้เข้าใจกันครับ มาเริ่มกันเลยดีกว่า</p>\n<h4 id="อะไรคือ-stream"><a href="#%E0%B8%AD%E0%B8%B0%E0%B9%84%E0%B8%A3%E0%B8%84%E0%B8%B7%E0%B8%AD-stream" aria-hidden="true"><span class="icon icon-link"></span></a>อะไรคือ Stream</h4>\n<p>มันคือ data flow ที่ไหลไปเรื่อยๆๆ ผู้อ่านทุกคน คงจะงงว่า "ไหลไปเรื่อยๆ" เป็นยังไง เดี๋ยวผมจะวาดภาพให้ดูรอสักแป็บนึงครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/G66FEoZ.png">\n</p>\n<p>ถ้าดูจากรูปจะเห็นว่าถ้าเราต้องการที่จะเขียนหรืออ่านไฟล์อะไรเราจะต้องใช้ function หลัก 2 ตัวนี้แน่นอน</p>\n<p><code>fs.readFile()</code>\n<br></p>\n<p><code>fs.writeFile()</code>\n<br></p>\n<p>แต่การทำแบบนี้มันผิดมากๆครับ ก็เพราะว่ามันคือรูปข้างบนที่ผมวาดไว้(รูปแรก) ทุกคนจะเห็นว่าวิธีการของมันก็คือเอาข้อมูลที่เราต้องเขียน อ่าน มาเก็บลง memory ตรงๆเลยแล้วถ้าสมมุติว่าขนาดไฟล์มีขนาด 4 GB บางคนอาจจะคิดว่า "โอ้ยสบาย server ผมน่ะมี RAM ตั้ง 128 GB แค่นี้สบายมากๆ" แต่ถ้าสมมุติว่ามีคนอัพโหลดไฟล์พร้อมกันประมาณ 100 คนและขนาด 4 GB เหมือนกันจะจัดการยังไงล่ะ คงไม่ไหวแน่นอนครับ ตรงจุดนี้ถึงเป็นเหตุสมควรที่จะใช้ Streams แล้วล่ะครับ</p>\n<br>\n<br>\n<p><strong>ข้อดี Stream</strong></p>\n<p>      1. ทำให้ใช้ memory ได้น้อยลงเพราะตัว Streams จะทำการค่อยๆ process ทีละนิดแล้วคอยเช็คว่าข้อมูลที่ต้องการ process ยังมีอยู่มั๊ย ถ้ายังมีอยู่ก็ process ต่อไป\n<br>\n      2. ทำให้ใช้เวลาเริ่มต้นการทำงานน้อยลงเพราะว่ามันไม่ต้องเสียเวลา process ก้อนข้อมูลอันใหญ่ มันก็แค่ค่อยทำทีละหน่อยๆ\n<br></p>\n<br>\n<br>\n<p><strong>หลักๆมี 4 แต่วันขอพูดแค่ 1</strong></p>\n<p>       1.Readable คือการอ่านข้อมูล\nจะเสียเวลาอยู่ทำไมกันมาดูตัวอย่างกันเลยดีกว่าครับ เดี๊ยว!!! ผมลืมอธิบายราละเอียดของ event และ function ต่างๆเลย ผมขออธิบายตรงนี้ก่อนนะครับ</p>\n<p>      event จะมีหลักๆก็จะมี</p>\n<p>      \'data\' เป็น event สำหรับคอยตรวจสอบเวลาที่มีข้อมูลเข้ามาใหม่</p>\n<p>      \'end\' เป็น event ที่จะบอกว่าไม่มีข้อมูลใหม่มาแล้ว</p>\n<p>      \'error\' เป็น event ที่คอยบอกว่าเกิด error อะไรขึ้นบ้างระหว่างทาง</p>\n<p>      \'close\' เป็น event ที่เกิดขึ้นตอนที่มีการเรียกใช้ destroy();\n<br>\n<br></p>\n<p>       function ก็จะมี</p>\n<p>       on() สำหรับเรียกใช้เพื่อที่จะตรวจสอบด้วย event ต่างๆ</p>\n<p>       push() สำหรับส่งข้อมูลเข้าไป</p>\n<p>       pause() หยุดการทำงานชั่วคราว</p>\n<p>       resume() สั่งให้ stream มีการทำงานต่อได้</p>\n<p>       isPaused() เป็นตัวเอาไว้ตรวจสอบว่า stream ตอนนี้มีการหยุดรึเปล่า</p>\n<p>       destroy() เป็นการ</p>\n<p>เฮ้อในที่สุดผมก็เขียนเสร็จสักที เสียเวลาอยู่ทำไมมาเริ่มตัวอย่างกันเลย~~~</p>\n<br>\n<br>\n<p><strong><em>ตัวอย่างที่ 1</em></strong></p>\n<br>\n<pre><code>const { Readable } = require(\'stream\')\n\nconst readStream = new Readable({\n  read(){}\n})\n\nreadStream.on(\'data\',(data)=>{\n  console.log(data)\n})\n\nreadStream.on(\'end\',()=>{\n  console.log("No more data")\n})\n\nreadStream.push("Hello world");\nreadStream.push("Hello Krapoke Node");\n\nreadStream.push(null);\n</code></pre>\n<p>ตรงนี้ผมได้ทำการสร้าง listener 2 ตัวโดยอันแรกสำหรับตรวจสอบว่ามีข้อมูลเข้ามาหรือไม่ และอันที่สองสำหรับตรวจสอบว่าจบการทำงานรึยัง ถัดมาทุกคนจะเห็นว่าผมได้ทำการส่งคำว่า "Hello world" กับ "Hello krapoke Node" เข้าไปใน stream และจบสุดท้ายด้วย <em>null</em> ตรงนี้ผมใส่ไปเพื่อที่จะบอกว่าจบสำหรับการ ก็จะได้ผลลัพธ์ตามนี้เลยครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/shWncqs.png">\n</p>\n<p>ทุกคนจะเห็นว่า จะส่งมาเป็น buffer ครับ แล้วถ้าเราต้องการจะแปลงเป็น string ก็แค่เปลี่ยน console.log(data) => console.log(data.toString) แค่นี้ก็ได้แล้วครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/YHARu4H.png">\n</p>\n<p>ทั้งหมดคือตัวอย่างแรกที่พูดถึงพื้นฐานของ read data stream ครับ เรามาดูต่อว่าการใช้ pause(), resume() เป็นยังไงกันนนนน</p>\n<br>\n<br>\n<p><strong>_ตัวอย่างที่ 2</strong></p>\n<pre><code>const { Readable } = require(\'stream\')\n\nconst readStream = new Readable({\n  read(){}\n})\n\nreadStream.on(\'data\',(data)=>{\n  console.log("data arrive => ",data.toString())\n})\n\nreadStream.on(\'end\',()=>{\n  console.log("No more data")\n})\n\n\nreadStream.push("Hello world");\n\nsetTimeout(()=>{\n  console.log("Pause Stream");\n  readStream.pause();\n},500)\n\nsetTimeout(()=>{\n  console.log("New data arrived");\n  readStream.push("Hello Krapoke Node");\n},1000)\n</code></pre>\n<p>ตรงนี้โค๊ดอาจจะงงนิดนึงครับ อธิบายคร่าวๆคือ ผมอ่านข้อมูล "Hello world" แล้วหลังจากนั้นเวลาผ่านไป 0.5 วินาทีให้ทำการหยุด stream ชั่วคราวดังนั้นทุกคนจะเห็นว่าอีก 0.5(1 วินาทีตั้งแต่เริ่มรัน) วินาที มีข้อมูลใหม่คือคำว่า "Hello Krapoke Node" ผลลัพธ์จะได้ตามนี้ครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/wqdCniW.png">\n</p>\nจะเห็นว่าไม่มี "Hello Krapoke Node" ออกมาเลยเพราะว่าผมได้ทำการหยุด stream ไว้ เลยทำให้ตัว stream ไม่ได้รับข้อมูลเข้ามาครับ\n<p>โอเคจบกันไปกับ readable stream ครับ</p>\n<br>\n',description:"",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/G66FEoZ.png"}}},{node:{id:"401787e3133ef9d748ea632d3edef0a7",date:"2 March, 2019",title:"Event-loop แบบพื้นฐานมากกกกก ตอนที่ 2 Event-loop มาสักที!!!",path:"/NodePost/event-loop-2",content:'<p>หลังจากที่ผมอธิบาย concept แบบคร่าวๆไปในครั้งที่แล้ว วันนี้เราจะลงลึกไประดับนึงครับ มาเริ่มกันเลยดีกว่า แต่ก่อนอื่นเลยที่เราจะมาทำความเข้าใจเรื่อง Event-loop มาคุยเรื่อง Reactor pattern กันก่อนนะครับ</p>\n<br>\n<h4 id="reactor-pattern"><a href="#reactor-pattern" aria-hidden="true"><span class="icon icon-link"></span></a>Reactor Pattern</h4>\n<p>      มันคืออะไรกันนะ มันก็คือ pattern ตัวนึงที่เข้าใจจัดการ event-driven architecture โดยตัวมันเนี๊ยจะทำการ พูดง่ายๆก็คือ Reactor Pattern ทำหน้าที่จัดการ process ที่ใช้เวลานานๆไปเป็น asynchronouse ครับ แล้วส่งกลับมาเป็น callback อย่างที่เรารู้จักกันนี้เอง</p>\n<p>โดยโครงสร้างของมันจะประกอบด้วย 4 ตัวหลักตามนี้ครับ</p>\n<p>      1. Resouce => ก็ตามชื่อเลยครับมันคือ resource for input &#x26; output</p>\n<br>\n<p>      2. Synchronous Event Demultiplexer => มันกับตัวแจ้งเตือนว่าทำงานเกี่ยวกับ I/O เสร็จแล้วส่งต่อไปที่ Event queue</p>\n<br>\n<p>      3. Event Queue => คือช่องที่เก็บ process ที่ต่อคิวกันรอกันอยู่</p>\n<br>\n<p>      4. Dispatcher => คือเอาตัว process จาก Event queue มาทำงานแล้วส่งกลับไป</p>\n<br>\n<p>เรียบร้อยแล้วครับสำหรับพื้นฐาน ของ Reactor Pattern เรามาเข้าเรื่อง Event-loop แบบจริงจังกันครับ มาลุยกัน~~~</p>\n<br>\n<h4 id="event-loop"><a href="#event-loop" aria-hidden="true"><span class="icon icon-link"></span></a>Event-loop</h4>\n<p>      ในที่สุดก็เข้าเรื่องพี่ loop สักที ผมขอเริ่มต้นที่รูปภาพแรกก็เลยครับ</p>\n<p><img src="https://i.imgur.com/GSBai6R.png" alt="GSBai6R.png"></p>\n<p>จะเห็นว่ามี 6 ขั้นตอนหลักๆ ผมจะเริ่มอธิบายเลยนะครับ เย้~</p>\n<p>      1. Application => จะทำการสร้าง request หรือ process เพื่อส่งต่อไปให้ Event Demultiplexer การทำงานในส่วนนี้เป็นแบบ Non-Blocking เพื่อทำงานส่งต่อไปที่ Event Demultiplexer</p>\n<br>\n<p>      2. Event Demultiplxer => เป็นจุดที่ทำงาน เกี่ยวกับ I/O ล้วนๆ เช่น อ่านไฟล์ เขียนไฟล์ เป็นต้น แล้วส่งต่อไปที่ Event queue</p>\n<br>\n<p>      3. Event queue => เป็นตัวเก็บ process ที่จะเรียกไปใช้งานผ่านเจ้า Even loop</p>\n<br>\n<p>      4. Event loop => จะคอยเช็คไปเรื่อยๆว่ามี process ค้างอยู่ใน Event queue รึเปล่าแล้ว ถ้ามีก็เอามาทำงานให้มันเสร็จจะได้ส่งกลับไป</p>\n<br>\n<p>      5. Handler => หลังจากที่ process นั้นๆทำงานเสร็จแล้วก็ส่งกลับมาว่า ฉันทำเสร็จแล้วน๊าาาา ไปทำ queue ต่อไปได้เลยเน้อ ในกรณีที่มี request ใหม่เข้ามาจะถูกถึงไปยัง ข้อ 1 แล้วทำตามขั้นตอนต่อไป</p>\n<br>\n<p>      6. Event loop ก็จะวนกลับไปทำงานในข้อหนึ่งใหม่ แล้วก็ทำอย่างนี้ไปเรื่อยๆ</p>\n<p>ในที่สุดผมก็เล่าเรื่อง Event loop เสร็จสักที แต่เดี๋ยวก่อนครับ การทำแบบนั้นมันคือแบบ Non-Blocking I/O แล้วถ้าเป็น Blocking I/O ล่ะจะทำยังไงดี มันก็จะเป็นสิ่งที่ผมพูดต่อจากนี้ครับ อย่าพึ่งเบื่อกันไปก่อนนะครับ จะจบแล้ว มาเริ่มเรื่องสุดท้ายของบทความนี้กัน</p>\n<br>\n<h4 id="thread-pool"><a href="#thread-pool" aria-hidden="true"><span class="icon icon-link"></span></a>Thread pool</h4>\n<p>เรามาพูดต่อให้ละเอียดขึ้นดีกว่าครับด้วยภาพนี้เลยครับ</p>\n<p><img src="https://i.imgur.com/WlaBgFV.png" alt="WlaBgFV.png"></p>\n<p>ที่จริงแล้วพี่ thread pool ของเราเอาไว้รับมือกับการทำงานที่เป็น blocking I/O ครับ โดยการทำงานของมันก็ง่ายแสนง่าย ก็คือมันจะทำการเช็คแต่ละ request มาเป็น Blocking I/O รึเปล่าถ้าเป็นก็ให้ส่ง request นั้นไปทำงานโดยมี thread pool เป็นตัวจัดการแทน event loop แต่เอ๊ะทำไมเรายังต้องใช้ thread pool อยู่แค่ event loop ก็น่าจะจัดการได้แล้วนี้น๊า แต่...มันผิดเลยครับเพราะตัว event loop จะ process อะไรที่ทำงานแป๊บเดียวก็เสร็จไม่เสียนานมากๆ แต่ถ้ามี request ที่ต้องใช้เวลานานมากๆล่ะอย่างเช่น การทำงานกับ file system หรือติดต่อ database ที่ใช้เวลานานๆ ตัว event loop เริ่มจะเป็นคอขวดแล้วใช่มั๊ยล่ะครับ นี้ถึงเป็นเหตุผลทำไมถึงมี thread pool และทำไม database driver ที่เราชอบใช้กันมันถึงเป็น callback,promise ครับ\nการทำงานของมันก็ตามรูปที่ผมวาดไว้เลยครับโดนการทำงานก็คือเช็ค request ว่าเป็น Blocking I/O รึเปล่าถ้าเป็นก็ไปเช็คว่าข้างในมี thread pool เหลือให้ใช้รึเปล่าโดยปรกติแล้วจะมีแค่ 4 ตัวเท่านั้นแต่เราสามารถเพิ่มได้โดยใช้คำสั่ง <strong><em>UV_THREADPOOL_SIZE=5</em></strong> ได้เลยครับ จะได้เพิ่มช่องสำหรับจัดการกับ Blocking I/O ที่จะเกิดขึ้นครับ</p>\n<br>\n<h4 id="เสริม"><a href="#%E0%B9%80%E0%B8%AA%E0%B8%A3%E0%B8%B4%E0%B8%A1" aria-hidden="true"><span class="icon icon-link"></span></a>เสริม</h4>\n<p>พยายามหลีกเลี่ยงการใช้งาน function ที่เป็นแบบ Blocking I/O ให้ได้ครับเพราะว่าจะไปทำงานอยู่บน thread pool มากเกินไปอย่างเช่น</p>\n<p><code>fs.fsyncSync(fd)</code>\n<br></p>\n<p><code>fs.lchmodSync(path, mode)</code></p>\n<br>\n<p>ก็จบกันแล้วนะครับสำหรับ Event loop ตอนสุดท้ายแบบพื้นฐานมากๆนะครับ ผมเกือบลืมเลย ปุกาศๆ ถ้าเราอีกสักหน่อยไม่น่าจะเกิน 10 ปีนี้ เดี๋ยวๆไม่ใช่สิ ไม่เกิน 2 เดือนข้างหน้าพวกเราอยากจะทำคลิปสอน NodeJS แบบฟรีๆ ไม่กั๊กอะไรทั้งนั้นแต่ถ้าใครบริจาคก็ได้ครับ แต่ที่สำคัญคือฟรี!!!!</p>\n<p>Ref:</p>\n<p><a href="https://en.wikipedia.org/wiki/Reactor_pattern" target="_blank" rel="nofollow noopener noreferrer">Reactor pattern</a></p>\n<p><a href="https://www.journaldev.com/7462/node-js-architecture-single-threaded-event-loop" target="_blank" rel="nofollow noopener noreferrer">Single Threaded Event Loop</a></p>\n<p><a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" target="_blank" rel="nofollow noopener noreferrer">Blocking vs Non-Blocking</a></p>\n<p><a href="https://www.future-processing.pl/blog/on-problems-with-threads-in-node-js/" target="_blank" rel="nofollow noopener noreferrer">On problems with threads in node.js</a></p>\n',description:"มาพูดถึงเรื่องที่ลงลึกไปอีกสักหน่อยครับ",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/GSBai6R.png"}}},{node:{id:"8a315b05460a5d06cf00e3005fcf4887",date:"16 February, 2019",title:"Event-loop แบบพื้นฐานมากกกกก ตอนที่ 1",path:"/NodePost/event-loop",content:'<p>สวัสดีครับผมกลับมาพบกับต้าคนเดิมคนดีอีกเช่นเคยนะครับ ซึ่งวันนี้ผมจะมาเล่าเรื่อง Event-loop ใน NodeJS ในภาษาและรูปภาพที่ทุกคนเข้าใจกันมาจะรอช้าอยู่ทำไมเข้าเรื่องกันเลย เดี๋ยวก่อนสิ ถ้าสำหรับใครที่ยังไม่ได้อ่านเรื่อง execution stack แนะนำให้กลับไปอ่านก่อนนะครับ <a href="https://krapokecode.github.io/BlogPost/exec-context-stack" target="_blank" rel="nofollow noopener noreferrer">link</a> จะได้เข้าใจมากขึ้น มาเข้าเรื่องกันเลยครับ</p>\n<h4 id="event-loop"><a href="#event-loop" aria-hidden="true"><span class="icon icon-link"></span></a>Event loop</h4>\n<p>คือการทำงานใน NodeJS เป็นแบบ Single-thread แล้วตัว single thread คืออะไร มาเริ่มที่ single thread กันก่อนนะครับ เริ่ม~~~</p>\n<p><img src="https://i.imgur.com/sxoUOEC.png" alt="sxoUOEC.png"></p>\n<p>ตรงนี้ทุกคนคนจะเห็นว่าในหนึ่ง process มันมีอยู่หนึ่ง thread ครับแต่ในความเป็นจริงแล้ว process สามารถมีได้หลายๆ thread โดยแต่ละตัวจะกระจายกันทำงานคนละแบบหรือทำงานแบบเดียวกันก็ได้ ทั้งหมดนี้คือ process &#x26; thread แบบพื้นฐานสุดๆ ได้เวลากลับมาเข้าเรื่องหลักกันครับ เรื่องของเรื่องก็คือ Event-loop มันทำงานอยู่แค่ thread เดียวครับ รูปภาพก็จะประมาณนี้ครับ</p>\n<pre><code>// Event loop\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │&#x3C;─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n</code></pre>\n<p>ผมต้องขอบอกก่อนว่าตัว NodeJS จะทำงานเป็นแบบคิววิ่งวนไปเรื่อยๆเพื่อเช็คว่ามีอะไรที่ต้องประมวลผลอีกรึเปล่า ประมาณนี้ครับ งั้นก็มาพูดถึงแต่ละตัวกันเลยครับ</p>\n<p><strong>Timers</strong></p>\n<p>      เป็นสิ่งแรกในการทำงานของ event loop สำหรับจัดการเป็นส่วนสำหรับเรียกใช้งาน function ที่เป็น callback เช่น <em>setTimeout()</em> , <em>setInterval()</em> เป็นต้น</p>\n<p><strong>Pending Callback</strong></p>\n<p>       สำหรับจัดการเมื่อ callback ทำงานเสร็จสิ้นหรือ error ครับ</p>\n<p><strong>Poll</strong></p>\n<p>      ตัว poll เป็นตัวรอรับ request หรือ I/O event อันใหม่</p>\n<p><strong>idle, prepare</strong></p>\n<p>       จะทำงานส่วนอยู่ใต้ลงไปอีก ผมขอพูดถึงบทบทความหน้าครับ ^^</p>\n<p><strong>check</strong></p>\n<p>       ตรงจุดนี้ใช้สำหรับประมวลผล <em>setImmediate()</em> ได้ครับ</p>\n<p><strong>Close callback</strong></p>\n<p>      ตามชื่อเลยครับ สำหรับปิด callback หรือ event ต่างๆ</p>\n<br>\n<p>ต้องขอตัดจบแบบละครไทยด้วยนะครับในบทความหน้าผมสัญญาว่าจะมาเล่าให้ละเอียดกว่านี้เพื่อให้ทุกคนเข้าใจมากขึ้นครับ</p>\n<p>ปล. ที่จริงมีเรื่อง Event-multiplexer, mico task blah blah ที่ผมยังไม่ได้พูดอีก เศร้า</p>\n',description:"อยู่ดีก็ผมก็อยากจะเขียนเรื่อง event loop ใน NodeJS ขึ้นมาแต่ต้องขอโทษด้วยครับเพราะเนื้อหามันเยอะมากก เลยต้องตัดแบ่งนะครับ",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/ywItdDB.png"}}},{node:{id:"de2871320f581a6179235614915d623e",date:"14 February, 2019",title:"Execution context and Execution Stack in javascript",path:"/NodePost/node-exec-context",content:'<p>ไหนๆวันนี้ก็เป็นวันวาเลนไทน์ของใครหลายๆคนแล้วแต่สำหรับผมมันก็แค่วันพฤหัสบดีที่แสนธรรมดา... เอาเวลาที่อิจฉาคนมีคู่มาเขียนบทความดีกว่า =__+\'\nสวัสดีครับกลับมาผมกับผมต้าคนเดิมคนดี วันนี้ผมรู้สึกคึ้กไปอ่านเรื่อง execution context กับ execution stack มาครับก็เลยมาเล่าให้ฟังครับ เริ่ม~~~</p>\n<p>ขอเกริ่นก่อนว่ามันคือ Stack ใน data structure นั้นเองครับทีนี้มาเข้าเรื่องกันเลยดีกว่า</p>\n<h4 id="execution-context"><a href="#execution-context" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Context</h4>\n<p>มันคือสภาพแวดล้อมสำหรับ Javascript ครับ สำหรับ running process ทั้งหมดโดยตัว execution context จะถูกแบ่งออกเป็น 3 ตัวครับ ตามนี้เลย</p>\n<br>\n<p><strong>Global</strong> => เหมือนกับก้อน object ใหญ่ๆที่เก็บ function สำคัญๆเอาไว้ ถ้านึกไม่ออกก็คือมันคือ <em>window</em> หรือ <em>this</em> ใน javascript นั้นแหล่ะครับ</p>\n<br>\n<p><strong>Functional</strong> => มันจะถูกสร้างเมื่อมีการเรียกใช้ function ครับ</p>\n<br>\n<p><strong>Eval</strong> => ตัวนี้จะถูกสร้างก็ต้องเมื่อเรียกใช้ <em>eval()</em></p>\n<br>\n<p>ตอนนี้ทุกคนก็พอรู้จัก execution context ในรูปแบบต่างๆแล้วนะครับ มาต่อกันที่ execution stack กันเลย 1 2 ฮึ้บ...</p>\n<br>\n<h4 id="execution-stack"><a href="#execution-stack" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Stack</h4>\n<p>ก่อนอื่นผมขออธิบายคร่าวๆเรื่อง stack ก่อนนะครับซึ่ง stack มันมี operation 2 อันคือ push กับ pop ซึ่งเป็นโครงสร้างการเก็บข้อมูลแบบนึงที่เป็นการทำงานแบบ LIFO(last in first) คือการเข้าทีหลังออกก่อนนั้นเอง ถ้าทุกคนยังไม่เข้าใจอยู่ ปริ้งภาพมา~~~</p>\n<p><img src="https://i.imgur.com/S38kijr.png" alt="S38kijr.png"></p>\n<p>แค่รูปนี้ทุกคนคงเข้าใจกันแล้ว ง่ายๆเลยคือ push คือการเพิ่มข้อมูลไว้บนสุดส่วนเจ้า pop คือการเอาข้อมูลที่อยู่บนสุดออกไปครับ ตัว Execution stack คือการที่เราเอาการเรียก function ไปเก็บลง stack นั้นเองครับเพื่อรอให้เจ้านายเรียกไปใช้งานนั้นเอง มันเป็นทำนองคลองเดียวกันเลยครับ ลองมาดูโค๊ดตัวอย่างพร้อมรูปภาพการทำงานกันเลยครับ</p>\n<pre><code>let a = 5;\nlet b = 10\nfunction add(x,y){\n  return x + y;\n}\n\nconst c = add(a,b);\n</code></pre>\n<p><img src="https://i.imgur.com/G02Mdah.png" alt="Imgur">\nทุกคนจะเห็นว่าตัว <em>add()</em> จะถูกเก็บลง call stack ก่อนเพื่อรอเจ้านาย(Global execution) เรียกใช้งานหลังจากนั้น <em>add()</em> ก็ถูกเรียกใช้ครับ เอ๊ะ! ผมลืมบอกว่า function, variable จะถูกเก็บลง global memory ไว้ก่อนนะครับ มาต่อที่ภาพที่สองกันเลย</p>\n<p><img src="https://i.imgur.com/5V0G5e4.png" alt="Imgur">\nหลังจากที่ตัว global execution ได้ทำการใช้งานทาส <em>add()</em> เป็นที่สำเร็จเสร็จสิ้นแล้ว พี่ global ส่งผลลัพธ์ไปเก็บที่ตัวแปร <em>C</em> ใน global memory เพื่อใช้งานต่อไป</p>\n<p>ก็จบไปแล้วสำหรับบทความนี้ถ้าใครค้างคาใจกับมาเรื่องก็มาคุยกับพวกเราได้ที่ Fanpage ได้นะครับ สำหรับวันนี้ก็ของลาไปก่อน สวัสดีวันวาเลนไทน์ครับ</p>\n<p>Ref:</p>\n<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="nofollow noopener noreferrer">Execution context and stack</a></p>\n<p><a href="https://www.valentinog.com/blog/js-execution-context-call-stack/" target="_blank" rel="nofollow noopener noreferrer">What Is The Execution Context?</a></p>\n',description:"ใครที่เขียน Javascript แล้วไม่รู้จัก 2 ตัวนี้ต้องอ่านเลยครับ ผมพยายามอธิบายให้เข้าใจง่ายที่สุดดดดดด",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/iX19pbS.png"}}}]}}}}}]);