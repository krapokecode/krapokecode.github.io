(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{64:function(n){n.exports={data:{allNodePost:{pageInfo:{totalPages:1,currentPage:1},edges:[{node:{id:"8a315b05460a5d06cf00e3005fcf4887",date:"16 February, 2019",title:"Event-loop แบบพื้นฐานมากกกกก ตอนที่ 1",path:"/NodePost/event-loop",content:'<p>สวัสดีครับผมกลับมาพบกับต้าคนเดิมคนดีอีกเช่นเคยนะครับ ซึ่งวันนี้ผมจะมาเล่าเรื่อง Event-loop ใน NodeJS ในภาษาและรูปภาพที่ทุกคนเข้าใจกันมาจะรอช้าอยู่ทำไมเข้าเรื่องกันเลย เดี๋ยวก่อนสิ ถ้าสำหรับใครที่ยังไม่ได้อ่านเรื่อง execution stack แนะนำให้กลับไปอ่านก่อนนะครับ <a href="https://krapokecode.github.io/BlogPost/exec-context-stack" target="_blank" rel="nofollow noopener noreferrer">link</a> จะได้เข้าใจมากขึ้น มาเข้าเรื่องกันเลยครับ</p>\n<h4 id="event-loop"><a href="#event-loop" aria-hidden="true"><span class="icon icon-link"></span></a>Event loop</h4>\n<p>คือการทำงานใน NodeJS เป็นแบบ Single-thread แล้วตัว single thread คืออะไร มาเริ่มที่ single thread กันก่อนนะครับ เริ่ม~~~</p>\n<p><img src="https://i.imgur.com/sxoUOEC.png" alt="sxoUOEC.png"></p>\n<p>ตรงนี้ทุกคนคนจะเห็นว่าในหนึ่ง process มันมีอยู่หนึ่ง thread ครับแต่ในความเป็นจริงแล้ว process สามารถมีได้หลายๆ thread โดยแต่ละตัวจะกระจายกันทำงานคนละแบบหรือทำงานแบบเดียวกันก็ได้ ทั้งหมดนี้คือ process &#x26; thread แบบพื้นฐานสุดๆ ได้เวลากลับมาเข้าเรื่องหลักกันครับ เรื่องของเรื่องก็คือ Event-loop มันทำงานอยู่แค่ thread เดียวครับ รูปภาพก็จะประมาณนี้ครับ</p>\n<pre><code>// Event loop\n   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │&#x3C;─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n</code></pre>\n<p>ผมต้องขอบอกก่อนว่าตัว NodeJS จะทำงานเป็นแบบคิววิ่งวนไปเรื่อยๆเพื่อเช็คว่ามีอะไรที่ต้องประมวลผลอีกรึเปล่า ประมาณนี้ครับ งั้นก็มาพูดถึงแต่ละตัวกันเลยครับ</p>\n<p><strong>Timers</strong></p>\n<p>      เป็นสิ่งแรกในการทำงานของ event loop สำหรับจัดการเป็นส่วนสำหรับเรียกใช้งาน function ที่เป็น callback เช่น <em>setTimeout()</em> , <em>setInterval()</em> เป็นต้น</p>\n<p><strong>Pending Callback</strong></p>\n<p>       สำหรับจัดการเมื่อ callback ทำงานเสร็จสิ้นหรือ error ครับ</p>\n<p><strong>Poll</strong></p>\n<p>      ตัว poll เป็นตัวรอรับ request หรือ I/O event อันใหม่</p>\n<p><strong>idle, prepare</strong></p>\n<p>       จะทำงานส่วนอยู่ใต้ลงไปอีก ผมขอพูดถึงบทบทความหน้าครับ ^^</p>\n<p><strong>check</strong></p>\n<p>       ตรงจุดนี้ใช้สำหรับประมวลผล <em>setImmediate()</em> ได้ครับ</p>\n<p><strong>Close callback</strong></p>\n<p>      ตามชื่อเลยครับ สำหรับปิด callback หรือ event ต่างๆ</p>\n<br>\n<p>ต้องขอตัดจบแบบละครไทยด้วยนะครับในบทความหน้าผมสัญญาว่าจะมาเล่าให้ละเอียดกว่านี้เพื่อให้ทุกคนเข้าใจมากขึ้นครับ</p>\n<p>ปล. ที่จริงมีเรื่อง Event-multiplexer, mico task blah blah ที่ผมยังไม่ได้พูดอีก เศร้า</p>\n',description:"อยู่ดีก็ผมก็อยากจะเขียนเรื่อง event loop ใน NodeJS ขึ้นมาแต่ต้องขอโทษด้วยครับเพราะเนื้อหามันเยอะมากก เลยต้องตัดแบ่งนะครับ",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/ywItdDB.png"}}},{node:{id:"de2871320f581a6179235614915d623e",date:"14 February, 2019",title:"Execution context and Execution Stack in javascript",path:"/NodePost/node-exec-context",content:'<p>ไหนๆวันนี้ก็เป็นวันวาเลนไทน์ของใครหลายๆคนแล้วแต่สำหรับผมมันก็แค่วันพฤหัสบดีที่แสนธรรมดา... เอาเวลาที่อิจฉาคนมีคู่มาเขียนบทความดีกว่า =__+\'\nสวัสดีครับกลับมาผมกับผมต้าคนเดิมคนดี วันนี้ผมรู้สึกคึ้กไปอ่านเรื่อง execution context กับ execution stack มาครับก็เลยมาเล่าให้ฟังครับ เริ่ม~~~</p>\n<p>ขอเกริ่นก่อนว่ามันคือ Stack ใน data structure นั้นเองครับทีนี้มาเข้าเรื่องกันเลยดีกว่า</p>\n<h4 id="execution-context"><a href="#execution-context" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Context</h4>\n<p>มันคือสภาพแวดล้อมสำหรับ Javascript ครับ สำหรับ running process ทั้งหมดโดยตัว execution context จะถูกแบ่งออกเป็น 3 ตัวครับ ตามนี้เลย</p>\n<br>\n<p><strong>Global</strong> => เหมือนกับก้อน object ใหญ่ๆที่เก็บ function สำคัญๆเอาไว้ ถ้านึกไม่ออกก็คือมันคือ <em>window</em> หรือ <em>this</em> ใน javascript นั้นแหล่ะครับ</p>\n<br>\n<p><strong>Functional</strong> => มันจะถูกสร้างเมื่อมีการเรียกใช้ function ครับ</p>\n<br>\n<p><strong>Eval</strong> => ตัวนี้จะถูกสร้างก็ต้องเมื่อเรียกใช้ <em>eval()</em></p>\n<br>\n<p>ตอนนี้ทุกคนก็พอรู้จัก execution context ในรูปแบบต่างๆแล้วนะครับ มาต่อกันที่ execution stack กันเลย 1 2 ฮึ้บ...</p>\n<br>\n<h4 id="execution-stack"><a href="#execution-stack" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Stack</h4>\n<p>ก่อนอื่นผมขออธิบายคร่าวๆเรื่อง stack ก่อนนะครับซึ่ง stack มันมี operation 2 อันคือ push กับ pop ซึ่งเป็นโครงสร้างการเก็บข้อมูลแบบนึงที่เป็นการทำงานแบบ LIFO(last in first) คือการเข้าทีหลังออกก่อนนั้นเอง ถ้าทุกคนยังไม่เข้าใจอยู่ ปริ้งภาพมา~~~</p>\n<p><img src="https://i.imgur.com/S38kijr.png" alt="S38kijr.png"></p>\n<p>แค่รูปนี้ทุกคนคงเข้าใจกันแล้ว ง่ายๆเลยคือ push คือการเพิ่มข้อมูลไว้บนสุดส่วนเจ้า pop คือการเอาข้อมูลที่อยู่บนสุดออกไปครับ ตัว Execution stack คือการที่เราเอาการเรียก function ไปเก็บลง stack นั้นเองครับเพื่อรอให้เจ้านายเรียกไปใช้งานนั้นเอง มันเป็นทำนองคลองเดียวกันเลยครับ ลองมาดูโค๊ดตัวอย่างพร้อมรูปภาพการทำงานกันเลยครับ</p>\n<pre><code>let a = 5;\nlet b = 10\nfunction add(x,y){\n  return x + y;\n}\n\nconst c = add(a,b);\n</code></pre>\n<p><img src="https://i.imgur.com/G02Mdah.png" alt="Imgur">\nทุกคนจะเห็นว่าตัว <em>add()</em> จะถูกเก็บลง call stack ก่อนเพื่อรอเจ้านาย(Global execution) เรียกใช้งานหลังจากนั้น <em>add()</em> ก็ถูกเรียกใช้ครับ เอ๊ะ! ผมลืมบอกว่า function, variable จะถูกเก็บลง global memory ไว้ก่อนนะครับ มาต่อที่ภาพที่สองกันเลย</p>\n<p><img src="https://i.imgur.com/5V0G5e4.png" alt="Imgur">\nหลังจากที่ตัว global execution ได้ทำการใช้งานทาส <em>add()</em> เป็นที่สำเร็จเสร็จสิ้นแล้ว พี่ global ส่งผลลัพธ์ไปเก็บที่ตัวแปร <em>C</em> ใน global memory เพื่อใช้งานต่อไป</p>\n<p>ก็จบไปแล้วสำหรับบทความนี้ถ้าใครค้างคาใจกับมาเรื่องก็มาคุยกับพวกเราได้ที่ Fanpage ได้นะครับ สำหรับวันนี้ก็ของลาไปก่อน สวัสดีวันวาเลนไทน์ครับ</p>\n<p>Ref:</p>\n<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="nofollow noopener noreferrer">Execution context and stack</a></p>\n<p><a href="https://www.valentinog.com/blog/js-execution-context-call-stack/" target="_blank" rel="nofollow noopener noreferrer">What Is The Execution Context?</a></p>\n',description:"ใครที่เขียน Javascript แล้วไม่รู้จัก 2 ตัวนี้ต้องอ่านเลยครับ ผมพยายามอธิบายให้เข้าใจง่ายที่สุดดดดดด",author:"Tar Jarupong",image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/iX19pbS.png"}}}]}}}}}]);