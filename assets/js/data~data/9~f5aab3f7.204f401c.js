(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{65:function(e){e.exports={data:{nodePost:{title:"NodeJS Stream ไหลดั่งสายน้ำ ตอนที่ 1 (Readable)",date:"15 March, 2019",content:'<p>NodeJS stream นี้มันอะไรกันนะ มันสำคัญขนาดนั้นเลยเหรอ ไม่เห็นเคยได้ยิน ใช่ผมก็ไม่เคยได้ยินแต่ด้วยต่อมอยากเ-อก เอ้ยอยากรู้มันทำงานก็เลยได้ไปศึกษามาแล้วอยากจะเขียนบทความให้ทุกคนได้เข้าใจกันครับ มาเริ่มกันเลยดีกว่า</p>\n<h4 id="อะไรคือ-stream"><a href="#%E0%B8%AD%E0%B8%B0%E0%B9%84%E0%B8%A3%E0%B8%84%E0%B8%B7%E0%B8%AD-stream" aria-hidden="true"><span class="icon icon-link"></span></a>อะไรคือ Stream</h4>\n<p>มันคือ data flow ที่ไหลไปเรื่อยๆๆ ผู้อ่านทุกคน คงจะงงว่า "ไหลไปเรื่อยๆ" เป็นยังไง เดี๋ยวผมจะวาดภาพให้ดูรอสักแป็บนึงครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/G66FEoZ.png">\n</p>\n<p>ถ้าดูจากรูปจะเห็นว่าถ้าเราต้องการที่จะเขียนหรืออ่านไฟล์อะไรเราจะต้องใช้ function หลัก 2 ตัวนี้แน่นอน</p>\n<p><code>fs.readFile()</code>\n<br></p>\n<p><code>fs.writeFile()</code>\n<br></p>\n<p>แต่การทำแบบนี้มันผิดมากๆครับ ก็เพราะว่ามันคือรูปข้างบนที่ผมวาดไว้(รูปแรก) ทุกคนจะเห็นว่าวิธีการของมันก็คือเอาข้อมูลที่เราต้องเขียน อ่าน มาเก็บลง memory ตรงๆเลยแล้วถ้าสมมุติว่าขนาดไฟล์มีขนาด 4 GB บางคนอาจจะคิดว่า "โอ้ยสบาย server ผมน่ะมี RAM ตั้ง 128 GB แค่นี้สบายมากๆ" แต่ถ้าสมมุติว่ามีคนอัพโหลดไฟล์พร้อมกันประมาณ 100 คนและขนาด 4 GB เหมือนกันจะจัดการยังไงล่ะ คงไม่ไหวแน่นอนครับ ตรงจุดนี้ถึงเป็นเหตุสมควรที่จะใช้ Streams แล้วล่ะครับ</p>\n<br>\n<br>\n<p><strong>ข้อดี Stream</strong></p>\n<p>      1. ทำให้ใช้ memory ได้น้อยลงเพราะตัว Streams จะทำการค่อยๆ process ทีละนิดแล้วคอยเช็คว่าข้อมูลที่ต้องการ process ยังมีอยู่มั๊ย ถ้ายังมีอยู่ก็ process ต่อไป\n<br>\n      2. ทำให้ใช้เวลาเริ่มต้นการทำงานน้อยลงเพราะว่ามันไม่ต้องเสียเวลา process ก้อนข้อมูลอันใหญ่ มันก็แค่ค่อยทำทีละหน่อยๆ\n<br></p>\n<br>\n<br>\n<p><strong>หลักๆมี 4 แต่วันขอพูดแค่ 1</strong></p>\n<p>       1.Readable คือการอ่านข้อมูล\nจะเสียเวลาอยู่ทำไมกันมาดูตัวอย่างกันเลยดีกว่าครับ เดี๊ยว!!! ผมลืมอธิบายราละเอียดของ event และ function ต่างๆเลย ผมขออธิบายตรงนี้ก่อนนะครับ</p>\n<p>      event จะมีหลักๆก็จะมี</p>\n<p>      \'data\' เป็น event สำหรับคอยตรวจสอบเวลาที่มีข้อมูลเข้ามาใหม่</p>\n<p>      \'end\' เป็น event ที่จะบอกว่าไม่มีข้อมูลใหม่มาแล้ว</p>\n<p>      \'error\' เป็น event ที่คอยบอกว่าเกิด error อะไรขึ้นบ้างระหว่างทาง</p>\n<p>      \'close\' เป็น event ที่เกิดขึ้นตอนที่มีการเรียกใช้ destroy();\n<br>\n<br></p>\n<p>       function ก็จะมี</p>\n<p>       on() สำหรับเรียกใช้เพื่อที่จะตรวจสอบด้วย event ต่างๆ</p>\n<p>       push() สำหรับส่งข้อมูลเข้าไป</p>\n<p>       pause() หยุดการทำงานชั่วคราว</p>\n<p>       resume() สั่งให้ stream มีการทำงานต่อได้</p>\n<p>       isPaused() เป็นตัวเอาไว้ตรวจสอบว่า stream ตอนนี้มีการหยุดรึเปล่า</p>\n<p>       destroy() เป็นการ</p>\n<p>เฮ้อในที่สุดผมก็เขียนเสร็จสักที เสียเวลาอยู่ทำไมมาเริ่มตัวอย่างกันเลย~~~</p>\n<br>\n<br>\n<p><strong><em>ตัวอย่างที่ 1</em></strong></p>\n<br>\n<pre><code>const { Readable } = require(\'stream\')\n\nconst readStream = new Readable({\n  read(){}\n})\n\nreadStream.on(\'data\',(data)=>{\n  console.log(data)\n})\n\nreadStream.on(\'end\',()=>{\n  console.log("No more data")\n})\n\nreadStream.push("Hello world");\nreadStream.push("Hello Krapoke Node");\n\nreadStream.push(null);\n</code></pre>\n<p>ตรงนี้ผมได้ทำการสร้าง listener 2 ตัวโดยอันแรกสำหรับตรวจสอบว่ามีข้อมูลเข้ามาหรือไม่ และอันที่สองสำหรับตรวจสอบว่าจบการทำงานรึยัง ถัดมาทุกคนจะเห็นว่าผมได้ทำการส่งคำว่า "Hello world" กับ "Hello krapoke Node" เข้าไปใน stream และจบสุดท้ายด้วย <em>null</em> ตรงนี้ผมใส่ไปเพื่อที่จะบอกว่าจบสำหรับการ ก็จะได้ผลลัพธ์ตามนี้เลยครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/shWncqs.png">\n</p>\n<p>ทุกคนจะเห็นว่า จะส่งมาเป็น buffer ครับ แล้วถ้าเราต้องการจะแปลงเป็น string ก็แค่เปลี่ยน console.log(data) => console.log(data.toString) แค่นี้ก็ได้แล้วครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/YHARu4H.png">\n</p>\n<p>ทั้งหมดคือตัวอย่างแรกที่พูดถึงพื้นฐานของ read data stream ครับ เรามาดูต่อว่าการใช้ pause(), resume() เป็นยังไงกันนนนน</p>\n<br>\n<br>\n<p><strong>_ตัวอย่างที่ 2</strong></p>\n<pre><code>const { Readable } = require(\'stream\')\n\nconst readStream = new Readable({\n  read(){}\n})\n\nreadStream.on(\'data\',(data)=>{\n  console.log("data arrive => ",data.toString())\n})\n\nreadStream.on(\'end\',()=>{\n  console.log("No more data")\n})\n\n\nreadStream.push("Hello world");\n\nsetTimeout(()=>{\n  console.log("Pause Stream");\n  readStream.pause();\n},500)\n\nsetTimeout(()=>{\n  console.log("New data arrived");\n  readStream.push("Hello Krapoke Node");\n},1000)\n</code></pre>\n<p>ตรงนี้โค๊ดอาจจะงงนิดนึงครับ อธิบายคร่าวๆคือ ผมอ่านข้อมูล "Hello world" แล้วหลังจากนั้นเวลาผ่านไป 0.5 วินาทีให้ทำการหยุด stream ชั่วคราวดังนั้นทุกคนจะเห็นว่าอีก 0.5(1 วินาทีตั้งแต่เริ่มรัน) วินาที มีข้อมูลใหม่คือคำว่า "Hello Krapoke Node" ผลลัพธ์จะได้ตามนี้ครับ</p>\n<p align="center">\n\t<img src="https://i.imgur.com/wqdCniW.png">\n</p>\nจะเห็นว่าไม่มี "Hello Krapoke Node" ออกมาเลยเพราะว่าผมได้ทำการหยุด stream ไว้ เลยทำให้ตัว stream ไม่ได้รับข้อมูลเข้ามาครับ\n<p>โอเคจบกันไปกับ readable stream ครับ</p>\n<br>\n<p>Ref:</p>\n<p><a href="https://nodejs.org/api/stream.html" target="_blank" rel="nofollow noopener noreferrer">doc</a></p>\n<p><a href="https://medium.freecodecamp.org/node-js-streams-everything-you-need-to-know-c9141306be93" target="_blank" rel="nofollow noopener noreferrer">node stream</a></p>\n',image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/G66FEoZ.png"},author:"Tar Jarupong"}}}}}]);