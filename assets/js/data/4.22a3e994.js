(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{58:function(n){n.exports={data:{blogPost:{title:"Execution context and Execution Stack in javascript",date:"14 February, 2019",content:'<p>ไหนๆวันนี้ก็เป็นวันวาเลนไทน์ของใครหลายๆคนแล้วแต่สำหรับผมมันก็แค่วันพฤหัสบดีที่แสนธรรมดา... เอาเวลาที่อิจฉาคนมีคู่มาเขียนบทความดีกว่า =__+\'\nสวัสดีครับกลับมาผมกับผมต้าคนเดิมคนดี วันนี้ผมรู้สึกคึ้กไปอ่านเรื่อง execution context กับ execution stack มาครับก็เลยมาเล่าให้ฟังครับ เริ่ม~~~ </p>\n<p>ขอเกริ่นก่อนว่ามันคือ Stack ใน data structure นั้นเองครับทีนี้มาเข้าเรื่องกันเลยดีกว่า</p>\n<h4 id="execution-context"><a href="#execution-context" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Context</h4>\n<p>มันคือสภาพแวดล้อมสำหรับ Javascript ครับ สำหรับ running process ทั้งหมดโดยตัว execution context จะถูกแบ่งออกเป็น 3 ตัวครับ ตามนี้เลย</p>\n<br>\n<p><strong>Global</strong> => เหมือนกับก้อน object ใหญ่ๆที่เก็บ function สำคัญๆเอาไว้ ถ้านึกไม่ออกก็คือมันคือ <em>window</em> หรือ <em>this</em> ใน javascript นั้นแหล่ะครับ</p>\n<br>\n<p><strong>Functional</strong> => มันจะถูกสร้างเมื่อมีการเรียกใช้ function ครับ</p>\n<br>\n<p><strong>Eval</strong> => ตัวนี้จะถูกสร้างก็ต้องเมื่อเรียกใช้ <em>eval()</em> </p>\n<br>\n<p>ตอนนี้ทุกคนก็พอรู้จัก execution context ในรูปแบบต่างๆแล้วนะครับ มาต่อกันที่ execution stack กันเลย 1 2 ฮึ้บ...</p>\n<br>\n<h4 id="execution-stack"><a href="#execution-stack" aria-hidden="true"><span class="icon icon-link"></span></a>Execution Stack</h4>\n<p>ก่อนอื่นผมขออธิบายคร่าวๆเรื่อง stack ก่อนนะครับซึ่ง stack มันมี operation 2 อันคือ push กับ pop ซึ่งเป็นโครงสร้างการเก็บข้อมูลแบบนึงที่เป็นการทำงานแบบ LIFO(last in first) คือการเข้าทีหลังออกก่อนนั้นเอง ถ้าทุกคนยังไม่เข้าใจอยู่ ปริ้งภาพมา~~~</p>\n<p><img src="https://i.imgur.com/S38kijr.png" alt="S38kijr.png"></p>\n<p>แค่รูปนี้ทุกคนคงเข้าใจกันแล้ว ง่ายๆเลยคือ push คือการเพิ่มข้อมูลไว้บนสุดส่วนเจ้า pop คือการเอาข้อมูลที่อยู่บนสุดออกไปครับ ตัว Execution stack คือการที่เราเอาการเรียก function ไปเก็บลง stack นั้นเองครับเพื่อรอให้เจ้านายเรียกไปใช้งานนั้นเอง มันเป็นทำนองคลองเดียวกันเลยครับ ลองมาดูโค๊ดตัวอย่างพร้อมรูปภาพการทำงานกันเลยครับ</p>\n<pre><code>let a = 5;\nlet b = 10\nfunction add(x,y){\n  return x + y;\n}\n\nconst c = add(a,b);\n</code></pre>\n<p><img src="https://i.imgur.com/G02Mdah.png" alt="Imgur">\nทุกคนจะเห็นว่าตัว <em>add()</em> จะถูกเก็บลง call stack ก่อนเพื่อรอเจ้านาย(Global execution) เรียกใช้งานหลังจากนั้น <em>add()</em> ก็ถูกเรียกใช้ครับ เอ๊ะ! ผมลืมบอกว่า function, variable จะถูกเก็บลง global memory ไว้ก่อนนะครับ มาต่อที่ภาพที่สองกันเลย</p>\n<p><img src="https://i.imgur.com/5V0G5e4.png" alt="Imgur">\nหลังจากที่ตัว global execution ได้ทำการใช้งานทาส <em>add()</em> เป็นที่สำเร็จเสร็จสิ้นแล้ว พี่ global ส่งผลลัพธ์ไปเก็บที่ตัวแปร <em>C</em> ใน global memory เพื่อใช้งานต่อไป</p>\n<p>ก็จบไปแล้วสำหรับบทความนี้ถ้าใครค้างคาใจกับมาเรื่องก็มาคุยกับพวกเราได้ที่ Fanpage ได้นะครับ สำหรับวันนี้ก็ของลาไปก่อน สวัสดีวันวาเลนไทน์ครับ</p>\n<p>Ref:</p>\n<p><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" target="_blank" rel="nofollow noopener noreferrer">Execution context and stack</a></p>\n<p><a href="https://www.valentinog.com/blog/js-execution-context-call-stack/" target="_blank" rel="nofollow noopener noreferrer">What Is The Execution Context?</a></p>\n',image:{type:"image",mimeType:"image/png",src:"https://i.imgur.com/iX19pbS.png"},author:"Tar Jarupong"}}}}}]);